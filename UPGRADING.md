# Upgrading

## 0.x to 1.0

The API underwent breaking changes between the 0.x and 1.x releases.

### Removal of Outer Constructs

`CircleCiOidcProvider` and `CircleCiOidcRole` now _extend_ `CfnOIDCProvider` and `Role`, respectively. This makes them
simpler to work with and more idiomatic to the CDK.

Because of this change, you might see changes like this in your CDK diff when upgrading:

```shell
Resources
[-] AWS::IAM::OIDCProvider CircleCiOidcProvider/CircleCiOidcProvider CircleCiOidcProviderBE49A2E7 destroy
[-] AWS::IAM::Role CircleCiOidcRole/CircleCiOidcRole CircleCiOidcRoleDC0C8DDB destroy
[+] AWS::IAM::OIDCProvider CircleCiOidcProvider CircleCiOidcProvider
[+] AWS::IAM::Role CircleCiOidcRole CircleCiOidcRoleC059EF20
```

If applied, this diff will destroy the old `CircleCiOidcProvider` and `CircleCiOidcRole` and create new ones. You have
two options to deal with this internal refactoring.

1. Destroy and recreate the affected providers and roles.
2. Prevent the destroy by overriding the logical ID of the new providers and roles.

#### Destroy and Recreate

This is the "cleanest" option because your CDK code won't contain overrides to work around the internal refactoring.
However, you'll likely have to issue two separate `cdk deploy` commands to destroy, then recreate the resources.

1. Delete the old resource from your stack and run a `cdk deploy`. This will destroy the old resource.
1. Add the new resource to your stack and run a `cdk deploy`. This will create the new resource. Note that if you're not
   passing the `roleName` property, you will likely get a new role name generated by CloudFormation.

NOTE: If you didn't specify an explicit `roleName` when creating the `CircleCiOidcRole`, you don't need to trigger two
deploys. The role name will be generated by CloudFormation and will be different from the old role name, so the new role
will be created, then the old one will be destroyed. You _must_ trigger two deploys with the `CircleCiOidcProvider`
because the name is static.

#### Prevent Destroy by Overriding Logical ID

If it would be disruptive to recreate your `CircleCiOidcProvider` or `CircleCiOidcRole`s, you can use the
`.overrideLogicalId` property to keep the old logical ID and prevent the destroy.

1. Run a `cdk diff` on your stack to see the logical IDs of the old resources that would be destroyed. You'll see output
   like this:

   ```shell
   Resources
   [-] AWS::IAM::OIDCProvider CircleCiOidcProvider/CircleCiOidcProvider CircleCiOidcProviderBE49A2E7 destroy
   [-] AWS::IAM::Role CircleCiOidcRole/CircleCiOidcRole CircleCiOidcRoleDC0C8DDB destroy
   [+] AWS::IAM::OIDCProvider CircleCiOidcProvider CircleCiOidcProvider
   [+] AWS::IAM::Role CircleCiOidcRole CircleCiOidcRoleC059EF20
   ```

1. Grab the old logical IDs and use them to override the logical IDs of the new resources. For example:

   ```typescript
   const provider = new CircleCiOidcProvider(this, "CircleCiOidcProvider", {
     organizationId: "123e4567-e89b-12d3-a456-426614174000",
   });
   provider.overrideLogicalId("CircleCiOidcProviderBE49A2E7");

   const role = new CircleCiOidcRole(this, "CircleCiOidcRole", {
     provider: provider,
   });
   (role.node.defaultChild as unknown as CfnResource).overrideLogicalId("CircleCiOidcRoleDC0C8DDB");
   ```

   By specifying the old logical IDs, you prevent the destroy of the old resources while still using the new underlying
   constructs.

1. Validate that the resources will not be destroyed by running another `cdk diff`. You should see that the old
   resources are no longer marked for destruction.

   ```shell
   There were no differences
   ```
